/**
 * ============================================================================
 * DATA SERVICE LIBRARY - ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÅ‡∏•‡∏∞‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥
 * ============================================================================
 *
 * ‡πÑ‡∏ü‡∏•‡πå‡∏ô‡∏µ‡πâ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏´‡∏ô‡∏∑‡πà‡∏≠‡∏¢‡∏•‡πâ‡∏≤
 * ‡∏£‡∏ß‡∏°‡∏ñ‡∏∂‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏ï‡πà‡∏≤‡∏á‡πÜ ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡πÉ‡∏ô Dashboard
 *
 * DEPENDENCIES:
 * - lib/firebase.ts: Firebase Realtime Database connection
 * - lib/types.ts: Type definitions
 * - lib/date-utils.ts: Date manipulation utilities
 *
 * USED BY:
 * - components/safety-dashboard.tsx: ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏•‡∏±‡∏Å
 * - components/charts-section.tsx: ‡πÅ‡∏™‡∏î‡∏á‡∏Å‡∏£‡∏≤‡∏ü‡πÅ‡∏•‡∏∞‡∏ä‡∏≤‡∏£‡πå‡∏ï
 * - app/dashboard/reports/page.tsx: ‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥
 */

import { database } from "./firebase"
import { ref, get, query, orderByChild, limitToLast, startAt, endAt } from "firebase/database"
import type { SensorData, DashboardStats, TimeRange } from "./types"

/**
 * ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå
 *
 * @param deviceId - ID ‡∏Ç‡∏≠‡∏á‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå (‡πÄ‡∏ä‡πà‡∏ô device_01)
 * @param limit - ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ (default: 100)
 * @returns Promise<SensorData[]> - ‡∏≠‡∏≤‡∏£‡πå‡πÄ‡∏£‡∏¢‡πå‡∏Ç‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå
 *
 * FIREBASE PATH: /sensor_data/{deviceId}/
 * QUERY: orderByChild('timestamp').limitToLast(limit)
 *
 * DATA STRUCTURE:
 * {
 *   timestamp: number,
 *   ear: number (0-1),
 *   mouth: number (0-1),
 *   safety_score: number (0-100)
 * }
 */
export async function getLatestSensorData(deviceId: string, limit = 100): Promise<SensorData[]> {
  try {
    console.log(`üìä DataService: Getting latest sensor data for ${deviceId}, limit: ${limit}`)

    // ‡∏™‡∏£‡πâ‡∏≤‡∏á reference ‡πÅ‡∏•‡∏∞ query
    const sensorRef = ref(database, `sensor_data/${deviceId}`)
    const sensorQuery = query(sensorRef, orderByChild("timestamp"), limitToLast(limit))

    // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Firebase
    const snapshot = await get(sensorQuery)

    if (!snapshot.exists()) {
      console.log(`üìä DataService: No sensor data found for ${deviceId}`)
      return []
    }

    // ‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏õ‡πá‡∏ô array ‡πÅ‡∏•‡∏∞‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏° timestamp
    const data: SensorData[] = []
    snapshot.forEach((childSnapshot) => {
      const sensorData = childSnapshot.val()
      data.push({
        timestamp: sensorData.timestamp,
        ear: sensorData.ear || 0,
        mouth: sensorData.mouth || 0,
        safety_score: sensorData.safety_score || 0,
      })
    })

    // ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡πÄ‡∏Å‡πà‡∏≤‡πÑ‡∏õ‡πÉ‡∏´‡∏°‡πà
    data.sort((a, b) => a.timestamp - b.timestamp)

    console.log(`üìä DataService: Retrieved ${data.length} sensor records`)
    return data
  } catch (error) {
    console.error("üî• DataService: Error getting sensor data:", error)
    return []
  }
}

/**
 * ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
 *
 * @param deviceId - ID ‡∏Ç‡∏≠‡∏á‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå
 * @param startTime - ‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô (timestamp)
 * @param endTime - ‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î (timestamp)
 * @returns Promise<SensorData[]> - ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
 *
 * FIREBASE QUERY:
 * orderByChild('timestamp').startAt(startTime).endAt(endTime)
 *
 * USE CASES:
 * - ‡∏î‡∏π‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏ï‡∏≤‡∏°‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà
 * - ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏õ‡∏£‡∏∞‡∏à‡∏≥‡∏ß‡∏±‡∏ô/‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå/‡πÄ‡∏î‡∏∑‡∏≠‡∏ô
 * - ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÅ‡∏ô‡∏ß‡πÇ‡∏ô‡πâ‡∏°‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏â‡∏û‡∏≤‡∏∞
 */
export async function getSensorDataByTimeRange(
  deviceId: string,
  startTime: number,
  endTime: number,
): Promise<SensorData[]> {
  try {
    console.log(
      `üìä DataService: Getting sensor data for ${deviceId} from ${new Date(startTime)} to ${new Date(endTime)}`,
    )

    const sensorRef = ref(database, `sensor_data/${deviceId}`)
    const timeRangeQuery = query(sensorRef, orderByChild("timestamp"), startAt(startTime), endAt(endTime))

    const snapshot = await get(timeRangeQuery)

    if (!snapshot.exists()) {
      return []
    }

    const data: SensorData[] = []
    snapshot.forEach((childSnapshot) => {
      const sensorData = childSnapshot.val()
      data.push({
        timestamp: sensorData.timestamp,
        ear: sensorData.ear || 0,
        mouth: sensorData.mouth || 0,
        safety_score: sensorData.safety_score || 0,
      })
    })

    data.sort((a, b) => a.timestamp - b.timestamp)

    console.log(`üìä DataService: Retrieved ${data.length} records for time range`)
    return data
  } catch (error) {
    console.error("üî• DataService: Error getting time range data:", error)
    return []
  }
}

/**
 * ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Dashboard
 *
 * @param sensorData - ‡∏≠‡∏≤‡∏£‡πå‡πÄ‡∏£‡∏¢‡πå‡∏Ç‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå
 * @returns DashboardStats - ‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏ó‡∏µ‡πà‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÅ‡∏•‡πâ‡∏ß
 *
 * CALCULATED METRICS:
 * - averageSafetyScore: ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢
 * - totalAlerts: ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
 * - fatigueEvents: ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏´‡∏ô‡∏∑‡πà‡∏≠‡∏¢‡∏•‡πâ‡∏≤
 * - activeTime: ‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏£‡∏∞‡∏ö‡∏ö (‡∏ô‡∏≤‡∏ó‡∏µ)
 * - lastUpdate: ‡πÄ‡∏ß‡∏•‡∏≤‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
 *
 * ALERT CRITERIA:
 * - Safety Score < 50: High Risk Alert
 * - Safety Score < 70: Medium Risk Alert
 * - Ear < 0.3: Eye Closure Alert
 * - Mouth > 0.7: Yawning Alert
 */
export function calculateDashboardStats(sensorData: SensorData[]): DashboardStats {
  console.log(`üìä DataService: Calculating dashboard stats for ${sensorData.length} records`)

  if (sensorData.length === 0) {
    return {
      averageSafetyScore: 0,
      totalAlerts: 0,
      fatigueEvents: 0,
      activeTime: 0,
      lastUpdate: Date.now(),
    }
  }

  // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢
  const totalSafetyScore = sensorData.reduce((sum, data) => sum + data.safety_score, 0)
  const averageSafetyScore = Math.round(totalSafetyScore / sensorData.length)

  // ‡∏ô‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô
  let totalAlerts = 0
  let fatigueEvents = 0

  sensorData.forEach((data) => {
    // High Risk Alert (Safety Score < 50)
    if (data.safety_score < 50) {
      totalAlerts++
      fatigueEvents++
    }
    // Medium Risk Alert (Safety Score < 70)
    else if (data.safety_score < 70) {
      totalAlerts++
    }

    // Eye Closure Alert (Ear < 0.3)
    if (data.ear < 0.3) {
      totalAlerts++
    }

    // Yawning Alert (Mouth > 0.7)
    if (data.mouth > 0.7) {
      totalAlerts++
    }
  })

  // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô (‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏£‡∏Å‡∏ñ‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢)
  const firstTimestamp = sensorData[0].timestamp
  const lastTimestamp = sensorData[sensorData.length - 1].timestamp
  const activeTime = Math.round((lastTimestamp - firstTimestamp) / (1000 * 60)) // ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ô‡∏≤‡∏ó‡∏µ

  const stats: DashboardStats = {
    averageSafetyScore,
    totalAlerts,
    fatigueEvents,
    activeTime,
    lastUpdate: lastTimestamp,
  }

  console.log("üìä DataService: Dashboard stats calculated:", stats)
  return stats
}

/**
 * ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏£‡∏≤‡∏ü‡πÅ‡∏™‡∏î‡∏á‡πÅ‡∏ô‡∏ß‡πÇ‡∏ô‡πâ‡∏°
 *
 * @param deviceId - ID ‡∏Ç‡∏≠‡∏á‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå
 * @param timeRange - ‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ ('1h', '6h', '24h', '7d')
 * @returns Promise<SensorData[]> - ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏£‡∏≤‡∏ü
 *
 * TIME RANGES:
 * - '1h': 1 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á‡∏ó‡∏µ‡πà‡∏ú‡πà‡∏≤‡∏ô‡∏°‡∏≤
 * - '6h': 6 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á‡∏ó‡∏µ‡πà‡∏ú‡πà‡∏≤‡∏ô‡∏°‡∏≤
 * - '24h': 24 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á‡∏ó‡∏µ‡πà‡∏ú‡πà‡∏≤‡∏ô‡∏°‡∏≤
 * - '7d': 7 ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ú‡πà‡∏≤‡∏ô‡∏°‡∏≤
 *
 * DATA SAMPLING:
 * - ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡∏±‡πâ‡∏ô: ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏∏‡∏Å‡∏à‡∏∏‡∏î
 * - ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏¢‡∏≤‡∏ß: ‡∏™‡∏∏‡πà‡∏°‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏î‡∏Ç‡∏ô‡∏≤‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
 */
export async function getChartData(deviceId: string, timeRange: TimeRange): Promise<SensorData[]> {
  try {
    console.log(`üìä DataService: Getting chart data for ${deviceId}, range: ${timeRange}`)

    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤
    const now = Date.now()
    let startTime: number

    switch (timeRange) {
      case "1h":
        startTime = now - 60 * 60 * 1000 // 1 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á
        break
      case "6h":
        startTime = now - 6 * 60 * 60 * 1000 // 6 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á
        break
      case "24h":
        startTime = now - 24 * 60 * 60 * 1000 // 24 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á
        break
      case "7d":
        startTime = now - 7 * 24 * 60 * 60 * 1000 // 7 ‡∏ß‡∏±‡∏ô
        break
      default:
        startTime = now - 60 * 60 * 1000 // default 1 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á
    }

    // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
    const data = await getSensorDataByTimeRange(deviceId, startTime, now)

    // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏¢‡∏≤‡∏ß ‡πÉ‡∏´‡πâ‡∏™‡∏∏‡πà‡∏°‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏î‡∏Ç‡∏ô‡∏≤‡∏î
    if (timeRange === "7d" && data.length > 500) {
      const sampledData: SensorData[] = []
      const step = Math.floor(data.length / 500)

      for (let i = 0; i < data.length; i += step) {
        sampledData.push(data[i])
      }

      console.log(`üìä DataService: Sampled data from ${data.length} to ${sampledData.length} points`)
      return sampledData
    }

    return data
  } catch (error) {
    console.error("üî• DataService: Error getting chart data:", error)
    return []
  }
}

/**
 * ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Ç‡∏≠‡∏á‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå
 *
 * @param deviceId - ID ‡∏Ç‡∏≠‡∏á‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå
 * @returns Promise<boolean> - true ‡∏ñ‡πâ‡∏≤‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏≠‡∏≠‡∏ô‡πÑ‡∏•‡∏ô‡πå
 *
 * CONNECTION CRITERIA:
 * - ‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà‡∏†‡∏≤‡∏¢‡πÉ‡∏ô 5 ‡∏ô‡∏≤‡∏ó‡∏µ‡∏ó‡∏µ‡πà‡∏ú‡πà‡∏≤‡∏ô‡∏°‡∏≤ = ‡∏≠‡∏≠‡∏ô‡πÑ‡∏•‡∏ô‡πå
 * - ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô 5 ‡∏ô‡∏≤‡∏ó‡∏µ = ‡∏≠‡∏≠‡∏ü‡πÑ‡∏•‡∏ô‡πå
 *
 * USED BY:
 * - components/connection-status.tsx: ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
 * - Dashboard components: ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå
 */
export async function checkDeviceConnection(deviceId: string): Promise<boolean> {
  try {
    console.log(`üìä DataService: Checking connection for ${deviceId}`)

    // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î 1 ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£
    const latestData = await getLatestSensorData(deviceId, 1)

    if (latestData.length === 0) {
      console.log(`üìä DataService: No data found for ${deviceId} - offline`)
      return false
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô 5 ‡∏ô‡∏≤‡∏ó‡∏µ
    const lastTimestamp = latestData[0].timestamp
    const fiveMinutesAgo = Date.now() - 5 * 60 * 1000

    const isOnline = lastTimestamp > fiveMinutesAgo
    console.log(`üìä DataService: Device ${deviceId} is ${isOnline ? "online" : "offline"}`)

    return isOnline
  } catch (error) {
    console.error("üî• DataService: Error checking device connection:", error)
    return false
  }
}

/**
 * Subscribe to historical data with caching for better performance
 *
 * @param deviceId - ID ‡∏Ç‡∏≠‡∏á‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå
 * @param startTime - ‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô (timestamp)
 * @param endTime - ‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î (timestamp)
 * @param callback - Callback function ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà
 * @returns Function to unsubscribe
 */
export function subscribeToHistoricalDataWithCache(
  deviceId: string,
  startTime: number,
  endTime: number,
  callback: (data: HistoricalData[], stats: DailyStats) => void,
): () => void {
  console.log(`üìä DataService: Subscribing to historical data with cache for ${deviceId}`)

  let isActive = true
  let lastFetchTime = 0
  const CACHE_DURATION = 30000 // 30 seconds cache

  const fetchData = async () => {
    if (!isActive) return

    try {
      const now = Date.now()
      if (now - lastFetchTime < CACHE_DURATION) {
        console.log(`üìä DataService: Using cached data for ${deviceId}`)
        return
      }

      console.log(`üìä DataService: Fetching fresh data for ${deviceId}`)
      const data = await getSensorDataByTimeRange(deviceId, startTime, endTime)

      // Convert SensorData to HistoricalData format
      const historicalData: HistoricalData[] = data.map((item, index) => ({
        id: `${deviceId}-${item.timestamp}-${index}`,
        timestamp: new Date(item.timestamp).toISOString(),
        ear_value: item.ear,
        ear: item.ear,
        yawn_events: item.mouth > 0.7 ? 1 : 0,
        drowsiness_events: item.ear < 0.25 ? 1 : 0,
        critical_alerts: item.safety_score < 30 ? 1 : 0,
        device_id: deviceId,
        status:
          item.safety_score < 30
            ? "CRITICAL: EXTENDED DROWSINESS"
            : item.ear < 0.25
              ? "DROWSINESS DETECTED"
              : item.mouth > 0.7
                ? "YAWN DETECTED"
                : "NORMAL",
        mouth_distance: item.mouth,
        face_detected_frames: 1,
      }))

      // Calculate daily stats
      const stats: DailyStats = {
        totalYawns: historicalData.filter((d) => d.yawn_events > 0).length,
        totalDrowsiness: historicalData.filter((d) => d.drowsiness_events > 0).length,
        totalAlerts: historicalData.filter((d) => d.critical_alerts > 0).length,
        averageEAR: data.length > 0 ? data.reduce((sum, d) => sum + d.ear, 0) / data.length : 0,
      }

      lastFetchTime = now

      if (isActive) {
        callback(historicalData, stats)
      }
    } catch (error) {
      console.error(`üî• DataService: Error fetching historical data for ${deviceId}:`, error)
      if (isActive) {
        callback([], {
          totalYawns: 0,
          totalDrowsiness: 0,
          totalAlerts: 0,
          averageEAR: 0,
        })
      }
    }
  }

  // Initial fetch
  fetchData()

  // Set up periodic refresh
  const interval = setInterval(fetchData, CACHE_DURATION)

  // Return unsubscribe function
  return () => {
    console.log(`üìä DataService: Unsubscribing from historical data for ${deviceId}`)
    isActive = false
    clearInterval(interval)
  }
}

// Simple function to get basic device status
export async function getDeviceStatus(deviceId: string): Promise<{ online: boolean; lastSeen?: string }> {
  try {
    console.log(`üìä DataService: Checking device status for ${deviceId}`)

    if (!database) {
      return { online: false }
    }

    const deviceRef = ref(database, `devices/${deviceId}/current_data`)
    const snapshot = await get(deviceRef)

    if (snapshot.exists()) {
      const data = snapshot.val()
      const lastSeen = data.timestamp ? new Date(data.timestamp).toISOString() : undefined
      const fiveMinutesAgo = Date.now() - 5 * 60 * 1000
      const online = data.timestamp ? new Date(data.timestamp).getTime() > fiveMinutesAgo : false

      return { online, lastSeen }
    }

    return { online: false }
  } catch (error) {
    console.error("üî• DataService: Error checking device status:", error)
    return { online: false }
  }
}

// Generate report function
export function generateReport(data: HistoricalData[], startDate: string, endDate: string) {
  console.log(`üìä DataService: Generating report from ${startDate} to ${endDate}`)

  return {
    summary: {
      totalEvents: data.length,
      yawnEvents: data.filter((d) => d.yawn_events > 0).length,
      drowsinessEvents: data.filter((d) => d.drowsiness_events > 0).length,
      criticalAlerts: data.filter((d) => d.critical_alerts > 0).length,
    },
    data: data,
    period: { startDate, endDate },
  }
}

export interface DailyStats {
  totalYawns: number
  totalDrowsiness: number
  totalAlerts: number
  averageEAR: number
}

export interface HistoricalData {
  id: string
  timestamp: string
  ear_value: number
  ear: number
  yawn_events: number
  drowsiness_events: number
  critical_alerts: number
  device_id: string
  status: string
  mouth_distance: number
  face_detected_frames: number
}

// ---------------------------------------------------------------------------
// Aggregated service export (for legacy imports)
// ---------------------------------------------------------------------------
export const dataService = {
  getLatestSensorData,
  getSensorDataByTimeRange,
  calculateDashboardStats,
  getChartData,
  checkDeviceConnection,
  subscribeToHistoricalDataWithCache,
  getDeviceStatus,
  generateReport,
}
